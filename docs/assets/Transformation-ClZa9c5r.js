import{V as t}from"./Universe-DpKi-MhS.js";class r{constructor(i=0){this.index=i}transform(i){const s=i.bodies[this.index].position.clone();return i.bodies.forEach(o=>{o.position.sub(s)}),i}}class l{transform(i){let s=0,o=new t;return i.bodies.forEach(n=>{s+=n.mass,o.add(n.position.clone().multiplyScalar(n.mass))}),o.divideScalar(s),i.bodies.forEach(n=>{n.position.sub(o)}),i}}class c{constructor(i,s){this.axis=i,this.angle=s}transform(i){return i.bodies.forEach(s=>{s.position.applyAxisAngle(this.axis,this.angle),s.velocity.applyAxisAngle(this.axis,this.angle),s.acceleration.applyAxisAngle(this.axis,this.angle)}),i}}class p{constructor(i,s=0){this.axis=i,this.index=s}transform(i){const s=i.bodies[this.index].position.clone().angleTo(this.axis.clone()),o=i.bodies[this.index].position.clone().cross(this.axis.clone()).normalize();return i.bodies.forEach(n=>{n.position.applyAxisAngle(o.clone(),s),n.velocity.applyAxisAngle(o.clone(),s),n.acceleration.applyAxisAngle(o.clone(),s)}),i}}class h{constructor(i,s){this.axis=i,this.revolutionTime=s}transform(i,s){const o=-(s/this.revolutionTime)*Math.PI*2;return i.bodies.forEach(n=>{n.position.applyAxisAngle(this.axis,o),n.velocity.applyAxisAngle(this.axis,o),n.acceleration.applyAxisAngle(this.axis,o)}),i}}export{r as B,l as C,p as P,c as R,h as T};
